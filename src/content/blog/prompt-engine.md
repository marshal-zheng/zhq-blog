---
author: ZHQ
pubDatetime: 2025-07-20T00:00:00+08:00
title: 'Prompt分类'
featured: false
draft: false
tags:
  - 'prompt'
description: '介绍零样本、少样本、思维链、从少到多、自我改进、助产式等多种提示方法'
---

最近在学习Prompt工程，在使用中LLM给我的感觉就像跟一个脑子快但有点“轴”的队友搭档：有时候它能秒懂你的需求，甩出神级代码；有时候却答得一团乱麻，气得想骂娘。经过一番探索和使用，我发现关键在**提示工程**（Prompt Engineering）。这玩意儿简直是门手艺活儿，提示写得好，模型就能变身你的超级代码助手；写得不好，纯属浪费算力。今天我想跟大家唠唠几种提示技巧，用点当下流行的 AI 编码场景，分享我在实践里的心得，争取让咱们开发者少走点弯路。

### 提示工程是啥？为啥值得折腾？

简单说，提示工程就是通过输入的指令和上下文，引导模型吐出你想要的答案。提示可以是一句直白的话，也可以复杂得像写需求文档。不同的提示方式就像跟模型聊天的套路，有的直接“发号施令”，有的得“哄着来”，甚至还能让它自己“反省”。这东西在 AI 编码项目里特别好使，比如生成代码注释、优化调试流程，或者自动写单元测试。设计好提示，模型就能帮你省不少力气。

### 零样本提示：直来直去，靠模型硬实力

零样本提示（Zero-shot Prompting）是最省心的招数：直接告诉模型干啥，不给任何例子，全靠它的“内功”。比如，我问：“分析 AI 代码补全工具为啥能提高开发效率”，模型可能回答：“AI 代码补全通过分析代码上下文，预测下一行代码，减少手动输入，像 GitHub Copilot 能节省 30% 的编码时间。” 这招适合简单问题，比如解释 AI 工具原理、生成短注释，或者分析技术趋势。

但零样本有短板。如果任务复杂点，比如要模型把代码补全的分析写成 JSON 格式，它可能只甩句概括，格式完全不对。这就像让一个新人直接写分布式系统，点子可能有，但细节肯定乱套。所以，得上点更高级的招。

### 少样本提示：扔几个例子，模型立马 get

少样本提示（Few-shot Prompting）就像给模型开个小灶，扔 2-5 个例子，让它摸清你的路子。比如，我想让模型给 AI 工具的输出打标签，可以这么写：

输入：AI 生成代码补全建议  
输出：标签：代码效率、自动化、开发者体验  
输入：AI 生成单元测试用例  
输出：标签：测试覆盖、质量保证、自动化  
输入：AI 优化调试日志分析  
输出：标签：错误定位、调试效率、日志解析  
输入：AI 生成 API 文档  

模型一看前三个例子，立马明白套路，回答：  
输出：标签：文档自动化、接口清晰、开发效率  

这招在 AI 编码项目里特别好使，比如给生成内容打标签、分类 bug 报告，或者优化 AI 输出格式。我最近搞了个 AI 代码审查工具，用少样本提示让模型生成了 bug 标签，省了我大把手动整理的时间。

### 思维链：让模型一步步想清楚

遇到需要算账或者推敲逻辑的任务，思维链提示（Chain-of-Thought, CoT）就派上场了。它要求模型把思路摊开，别直接甩答案。比如：

**问题**：用 AI 预测一个代码补全工具每天生成 1000 行代码，每行代码节省 0.1 元的开发成本，每周运行 7 天，算一周节省的成本。  
**提示**：一步步推理，讲清楚每步咋算的。  
**输出**：  
1. 每天节省成本：1000 行 × 0.1 元 = 100 元。  
2. 一周 7 天，总节省：100 × 7 = 700 元。  
答案：一周节省成本是 700 元。

CoT 的好处是让模型的脑回路清清楚楚，像写代码时加了注释，错了也能一眼揪出来。我最近用 AI 分析代码生成工具的 ROI 时，就用 CoT 让模型一步步拆解逻辑，省得它给我个糊涂账。

### 从少到多：把大问题拆成小块啃

如果任务复杂到 CoT 都觉得吃力，从少到多提示（Least-to-Most Prompting）是个好办法。它要求模型把问题拆成小块，一步步解决。比如：

**问题**：用 AI 预测一个调试助手每天处理 1000 个错误日志，每次处理节省 0.2 元的调试时间，每周活跃 5 天，一个月 4 周，算月节省成本。  
**提示**：把问题拆成小块，逐步解决。  
**输出**：  
1. 每天节省成本：1000 次 × 0.2 元 = 200 元。  
2. 每周节省：200 × 5 天 = 1000 元。  
3. 每月节省：1000 × 4 周 = 4000 元。  
答案：月节省成本是 4000 元。

这招就像写代码时把大函数拆成小函数，清晰又稳妥。我在用 AI 优化调试流程时，常用这种方法拆解成本分析，从日数据到月汇总，逻辑清楚，Bug 也好排查。

### 自我改进：让模型自己“code review”

自我改进提示（Self-Refine Prompting）有点像让模型给自己做“code review”。它先生成个初稿，然后自己检查、优化。比如：

**问题**：用 AI 写一段分析代码生成工具优点的描述，包含 3 个关键特点。完成后检查完整性并改进。  
**初稿**：  
代码生成工具能自动写代码，节省时间。  
**反思**：  
初稿只提了 1 个特点（节省时间），没凑够 3 个，描述也太笼统，缺少具体亮点。  
**改进稿**：  
代码生成工具是开发者的神器。1) 提升效率：自动补全代码，减少 30% 手动输入时间；2) 降低错误：AI 分析上下文，生成更可靠的代码；3) 支持复杂任务：能生成从 API 文档到单元测试的多种输出。

这招特别适合需要高质量输出的场景，比如写 AI 工具分析报告或优化算法描述。我在搞 AI 代码生成项目时，常用 Self-Refine 确保分析结果逻辑严密、表述清晰。

### 助产式提示：像苏格拉底一样“盘”出真相

助产式提示（Maieutic Prompting）有点像跟模型玩“苏格拉底问答”，让它自己提问题、掰扯清楚。比如：

**问题**：为什么 AI 调试助手能提高开发效率？  
**提示**：先提两个相关问题，回答后再综合出结论。  
**输出**：  
- 问题 1：AI 调试助手怎么定位代码错误？  
  AI 通过分析日志和代码上下文，快速定位 bug，比手动排查快 50%。  
- 问题 2：AI 调试助手对复杂项目有啥帮助？  
  AI 能处理大规模代码库，识别隐藏的逻辑错误，减少调试死锁的时间。  
**结论**：  
AI 调试助手提高开发效率，因为它快速定位 bug，节省排查时间，同时在复杂项目中能识别深层逻辑问题。

这招在分析 AI 工具效果时特别好使，比如研究代码生成器的收益或调试算法的优化。我最近分析 AI 调试工具时，用助产式提示挖出了不少深层洞察。

### 提示工程的魅力与坑

提示工程的牛处在于，它能把模型从“死板的工具”变成“靠谱的搭档”。零样本适合快问快答，少样本适合格式化输出，思维链和从少到多专治复杂计算，自我改进和助产式则能挖出深层洞察。在 AI 编码项目里，比如优化代码补全、调试流程，这些技巧都能派上用场。

但踩坑也在所难免。设计好提示得花时间试错，例子挑不好或者指令不清晰，模型就可能“跑火车”。而且，模型能力有天花板，再牛的提示也救不了训练数据的短板。还有，复杂提示会增加算力成本，批量任务时得悠着点。

### 总结：多练多试，找到自己的“提示配方”

提示工程就像给模型装了个“方向盘”，让我们能更精准地控制输出。零样本快、少样本准、思维链透、从少到多稳、自我改进精、助产式深，每招都有它的舞台。作为开发者，我的建议是多试多练，找到适合你项目的“提示配方”。未来，模型会越来越聪明，提示工程可能也会进化，比如自动优化提示，或者结合代码知识库让输出更精准。

你最近用 LLM 踩过啥坑？有啥提示技巧想分享？欢迎在评论区聊聊，咱们一起“脑洞大开”！
